---
title: "RStudio - Debugging and Performance Tools"
description: "Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize."
lead: "Doks is a Hugo theme for building secure, fast, and SEO-ready documentation websites, which you can easily update and customize."
date: 2023-1-09T08:48:57+00:00
lastmod: 2023-1-09T08:48:57+00:00
draft: false
images: []
menu:
  docs:
    parent: "tools"
weight: 030
toc: true
---

# Error and Debugging Basics

Errors and debugging is something you will have to deal with a lot in R. Thankfully, R has multiple indications that something's not right:

* `message` - A generic notification / diagnostic message produced by the `message()` function; execution of the function continues 
* `warning` - An indication that something is wrong, but not necessarily fatal; execution of the function continues; generated by the `warning()` function 
* `error` - An indication that a fatal problem has occured; execution stops; produced by the `stop()` function 
* `condition` - A generic concept for indicating something unexpected can occur; programmers can create their own conditions

Here's an example of a warning:

```{r warningEx}
log(-1)
```

Here is how you can have R print a message:

```{r messageEx}
printmessage <- function(x) {
    if(is.na(x))
        print("x is a missing value!")
    else if(x > 0)
        print("x is greater than zero")
    else
        print("x is less than or equal to zero")
    invisible(x)
}
printmessage(1)
printmessage(NA) # would return an error if first if() was not there
```

The above function can be a part of a larger function, and can act as a debugging tool in the beginning. `invisible()` is a useful function that tells R to not autoprint return objects (makes them invisible)

## Basic Function-Oriented Debugging Tools in R 

There are a few primary tools you can use for debugging functions:

* `traceback()` - prints out the function call stack after an error occurs 
    * A function call stack is a list of the functions that a function called throughout it being executed
* `debug()` - flags a function for "debug" mode, which allows you to step through execution of a function one line at a time 
    * Debug mode means that whenever a funciton is called, the browser will automatically open up so you can step into the function (even if it's in another!)
* `browser()` - suspends the execution of a function wherever it is called and puts the function in debug mode (rather than the first line)
    * when in browser mode, type `n` for next line, `q` to quit
* `trace()` - allows you to insert debugging code into a function at specific places
* `recover()` - allows you to modify the error behavior so that you can browse the funciton call stack 
* The very blunt technique of using `print/cat` statements in the function is also okay

Here some examples of them in use (use this code in the terminal to see the errors and use them):

```{r debugEx, eval = FALSE}
mean(x)
# returns error in mean(x)
traceback()
# 1: mean(x) is what it would return in R
lm(y - x) 
# returns error in eval...
traceback() # shows the 7 level call stack
debug(lm)
lm(y - x)
n # next line (the 2 shows that we are in level 2 of the browser)
n # next line
q # quit browse mode
options(error = recover)
read.csv("nosuchfile")
0
```

## Basics Summary 

There are three main indicators of a problem: message, warning, error (only error is fatal).

When analyzing a function with a problem, make sure you can reproduce the problem, state your expectations, and explain how the output differs from the expectation.

Debugging tools are not a substitute for thinking, try to figure it out first!

# Debugging and Performance Tools

There are numerous debugging and performance tools in R

## Optimiazation Using R Profiler

Profiling is a way to examine how much time is spent in different parts of a program, which is useful when trying to optimize code.

It may not be noticeable when you are running code a couple times, but it could really affect you when you are looping something a thousand times. It is also helpful to wait until things are built up a bit before being optimized.

Remember:

* Design first, then optimize
* Premature optimization is the root of all evil
* Measure (collect data), don't guess

### System.time()

Before getting into the profiler, we're going to take a look at a more rudimentary option for assessing speed. 

The `system.time()` function takes an arbitrary expression, and returns the amount of time taken to evaluate the expression.

* If there's an error, it will return the time until the error was reached
* Returns an object of class `proc_time`
    * **user time** - Time charged to the CPU for the expression 
    * **system time** - Not sure yet
    * **elapsed time** - "Wall clock" time, what a person experiences

```{r sysTime}
# example where Elapsed > user, due to waiting for url response
system.time(readLines("http://www.jhsph.edu"))

# example where Elapsed < user, due to it being split between cpu cores
hilbert <- function(n) {
    i <- 1:n
    1 / outer(i - 1, i, "+")
}
x <- hilbert(1000)
system.time(svd(x))
```

### R Profiler

The R Profiler is represented by the function `Rprof()`. The `summaryRprof()` function is necessary to read the output of `Rprof`.

It keeps track of the function call stack at a regularly sampled interval (default is 0.02 seconds).

When using `summaryRprof`, there are two methods for normalizing the data:

* `by.total` divides the time spent in each function by total run time 
* `by.self` does the same, but first subtracts out time spent in functions above it in the call stack 

It will create a document when used, and it will then store the analysis of each function used after it is called.

Find examples online! https://bookdown.dongzhuoer.com/hadley/adv-r/profiling.html

`Rprof(NULL)` can be used to stop it.